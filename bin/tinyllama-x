#!/usr/bin/env bash
set -euo pipefail

# TinyLlama-X unified CLI launcher with version/help support
# Preference order: smart -> auto -> simple -> classic.

log() { printf "%s\n" "$*"; }
err() { printf "Error: %s\n" "$*" >&2; }

SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" 2>/dev/null && pwd)"

get_version() {
  local v
  if command -v git >/dev/null 2>&1; then
    if v=$(git -C "$SCRIPT_DIR" describe --tags --dirty --always 2>/dev/null); then
      printf "%s" "$v"; return 0
    fi
    # Try parent (installed layout may put bin/ in root)
    if v=$(git -C "$SCRIPT_DIR/.." describe --tags --dirty --always 2>/dev/null); then
      printf "%s" "$v"; return 0
    fi
  fi
  if [[ -f "$SCRIPT_DIR/.tinyllama_version" ]]; then
    cat "$SCRIPT_DIR/.tinyllama_version"; return 0
  fi
  date +%Y.%m.%d
}

print_usage() {
  cat <<EOF
TinyLlama-X CLI

Usage: tinyllama-x [options] [-- underlying-script-args]

Options:
  -h, --help       Show this help
  -v, --version    Show version info

Description:
  Locally hosted TinyLlama assistant. Automatically selects the most
  capable launcher script available (smart intent assistant preferred).

Environment overrides:
  TINYLLAMA_X_DIR      Install or repo directory
  TINYLLAMA_X_MODEL    Absolute path to GGUF model
  TINYLLAMA_X_VENV     Python virtualenv path
EOF
}

resolve_app_dir() {
  if [[ -n "${TINYLLAMA_X_DIR:-}" && -d "$TINYLLAMA_X_DIR" ]]; then
    printf "%s" "$TINYLLAMA_X_DIR"; return 0
  fi
  local candidates=(
    "/opt/TinyLlama-X"
    "$HOME/.local/share/TinyLlama-X"
    "/opt/tinyllama-x"
    "$HOME/.local/share/tinyllama-x"
  )
  for d in "${candidates[@]}"; do
    [[ -d "$d" ]] && { printf "%s" "$d"; return 0; }
  done
  # Fallback to repo checkout parent directory
  printf "%s" "$(cd "$SCRIPT_DIR/.." 2>/dev/null && pwd)"
}

is_executable_nonempty() { [[ -s "$1" && ( -x "$1" || -r "$1" ) ]]; }

find_first() {
  local base="$1"; shift
  local name p
  for name in "$@"; do
    for p in \
      "$base/$name" \
      "$base/tinyllama-x/$name" \
      "$base/tinyllama-x/tinyllama-x/$name"; do
      if is_executable_nonempty "$p"; then
        printf "%s" "$p"; return 0
      fi
    done
  done
  return 1
}

handle_args() {
  local passthrough=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help|help)
        print_usage; exit 0 ;;
      -v|--version|version)
        echo "TinyLlama-X $(get_version)"; exit 0 ;;
      --) shift; passthrough+=("$@"); break ;;
      *) passthrough+=("$1") ;;
    esac
    shift || true
  done
  printf '%s\n' "${passthrough[@]}" | sed '/^$/d'
}

main() {
  local args
  # Capture processed args (newline separated); convert to array
  mapfile -t args < <(handle_args "$@")

  local app_dir
  app_dir="$(resolve_app_dir)"

  local entry
  if ! entry="$(find_first "$app_dir" \
      ai_terminal_llama_smart.sh \
      ai_terminal_llama_auto.sh \
      ai_terminal_llama_simple.sh \
      ai_terminal_llama.sh \
      ai_terminal.sh)"; then
    err "No suitable launcher script found under $app_dir"
    exit 1
  fi

  chmod +x "$entry" 2>/dev/null || true
  log "Starting TinyLlama-X (version: $(get_version)) via $(basename "$entry")..."
  exec bash "$entry" "${args[@]}"
}

main "$@"
